# Chain of Responsibility 패턴 📚 - 책임 떠넘기기

### Chain of Responsibility
- 담당자를 찾을 때까지 다음 사람, 다음 사람으로 자신의 요구가 차례로 넘겨지는 것이 '책임 떠넘기기'이다
- 어떤 요청이 발생했을 때 그 요청을 처리할 오브젝트를 직접 결정할 수 없는 경우, <br>
  복수의 오브젝트(객체)를 사슬(chain)처럼 연결해두면, <br>
  그 오브젝트(객체)의 **사슬을 차례로 돌아다니면서 목적한 오브젝트(객체)를 결정하는 방법**
- 요청자/처리자의 연결을 유연하게 해서 각 오브젝트를 부품으로 독립시킬 수 있다
- 상황에 따라서 요청을 처리할 오브젝트가 변하는 프로그램에도 대응할 수 있습니다.

---


#### 예제



--- 
### Chain of Responsibility 패턴의 등장인물
- Handler(처리자)의 역할
  - 요구를 처리하는 인터페이스(API)를 결정하는 역할 -> 예제 프로젝트의 Support
  - '다음 사람'(다른 Handler)을 준비해두고 자신이 처리할 수 없는 요구가 나오면 그 사람에게 떠넘기는 역할
- ConcreteHandler(구체적인 처리자)의 역할
  - 요구를 처리하는 구체적인 역할 -> 예제 프로젝트의 {NoSupport, OddSupport, LimitSupport, ...}
- Client
  - 최초의 ConcreteHandler 역할에 요구하는 일을 한다 -> 예제 프로그램의 Main
---
# 📌 Check

---

### TIP! 요구자와 처리자를 유연하게 연결
- Chain of Responsibility 패턴의 포인트는 요구자(Client)와 처리자(ConcreteHandler)를 유연하게 연결하는 것
- Client 역할은 최초의 사람에게 요구, 그리고 뒷일은 사슬 안으로 그 요구가 전달되어 **적절한 처리자에 의해 요구가 처리**된다 
> if Chain of Responsibility 패턴이 없다면? <br>
> '이 요구는 이 사람이 처리해야한다'라는 정보를 누군가가 중앙집권적으로 가지고 있어야 한다
> 그 정보는 요구자가 가지고 있는 것은 현명하지 않다 <br>
>  ▶ 요구자가 처리자들의 역할 분담까지 알아야한다면 부품으로써 독립성이 떨어진다

<br>

### 동적으로 사슬의 형태를 바꾼다
예시 프로그램에서는 서포트 팀이 항상 고정된 순서가 있지만, 요구를 처리하는 ConcreteHandler 역할의 오브젝트 관계가 동적으로 변화하는 상황도 생각할 수 있다.
**Chain of Responsibility 패턴 같이 '위임'에 의해 떠넘기기를 실행하고 있으면 상황의 변화에 따라서 ConcreteHandler 역할을 재편할 수 있다**

### QUESTION? 떠넘기기로 처리가 지연되지 않을까?
떠넘기기를 수행하면 틀림없이 유연성은 높을지 모르겠지만 처리가 지연되지 않을까?
▶ 지연된다. 누가 요구를 처리할 것인지 미리 정해져 있고 그 상대가 바로 처리하는 경우와 비교하면 지연된다!
BUT, 이것은 트레이드 오프의 문제
▶ 요구&처리자가 고정적이고 처리 속도가 중요한 경우에는 Chain of Responsibility 패턴을 사용하지 않는 편이 유효할 때가 있다