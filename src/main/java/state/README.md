# State 패턴 📚 - 상태를 클래스로 표현하기

### State
- 사물의 모양이나 형편을 의미하는 상태를 클래스로 표현하는 방법
- 상태를 클래스로 표현하면 클래스를 교체해서 **상태의 변화**를 표현할 수 있고, 새로운 상태를 추가해야 될 때 무엇을 프로그램하면 좋을지 명확

---

#### 예제

---
#### State 패턴을 사용하지 않은 방법
```
경비시스템의 클래스 {
    금고 사용시에 호출되는 메소드() {
        if(주간) {
            경비센터에 이용 기록
        } else if(야간) {
            경비센터에 비상사태 통보
        }
    }
    비상벨 사용시에 호출되는 메소드() {
        경비센터에 비상벨 통보
    }
    일반 통화시에 호출되는 메소드() {
        if(주간) {
            경비센터의 호출
        } else if(야간) {
            경비센터의 자동응답기 호출
        }
    }
}
```

---
#### State 패턴을 사용한 방법
```
주간 상태 클래스 {
    금고 사용시 호출되는 메소드() {
        경비센터에 이용 기록
    }
    비상벨 사용시에 호출되는 메소드() {
        경비센터에 비상벨 통보
    }
    일반 통화시 호출되는 메소드() {
        경비센터의 호출
    }
}
야간 상태 클래스 {
    금고 사용시에 호출되는 메소드() {
        경비센터에 비상상태 통보
    }
    비상벨 사용시에 호출되는 메소드() {
        경비센터에 비상벨 통보
    }
    일반 통화시에 호출되는 메소드() {
        경비센터의 자동응답기 호출
    }
    
}
```
--- 
### State 패턴의 등장인물
- State(상태)의 역할
  - 상태를 나타낸다
  - 상태가 변할 때마다 다른 동작을 하는 인터페이스(API)를 결정
    - 인터페이스(API)는 상태에 의존한 동작을 하는 메소드의 집합
- ConcreteState(구체적인 상태)의 역할
  - 구체적인 각각의 상태를 표현
- Context(상황, 전후관계, 문맥)의 역할
  - 현재의 상태를 나타내는 ConcreteState 역할을 **가진다**
  - State 패턴의 이용자에게 필요한 인터페이스(API)를 결정
    - Context 인터페이스 : 인터페이스(API)를 결정하는 부분 담당
    - SafeFrame 클래스 : ConcreteState 역할을 가지는 부분을 담당
---
# 📌 Check

---

### TIP! 상태에 의존한 처리
예제 프로그램의 SafeFrame 클래스의 setClock 메소드와 State 클래스의 doClock의 관계는?
> Main은 SafeFrame 클래스의 setClock 메소드를 호출하여 '시간의 설정'을 지시하고, 
> setClock 메소드 안에서 그 처리를 state의 doClock() 메소드로 위임한다.
> **시간의 설정을 '현재 상태에 의존한 처리'로 취급하고 있다**

<br>

예제 프로그램에서 Context(SafeFrame)이 changeState()를 구현하며, ConcreteState 역할의 DayState or NightState 클래스를 호출한다
**즉, '상태전환'을 '상태에 의존한 동작'으로 간주하고 있다**
#### 이런 방식의 장점
- '다른 상태로 전환하는 것은 언제인가'의 정보가 하나의 클래스 내에 정리되어 있는 점

#### 이런 방식의 단점
- '하나의 ConcreteState 역할이 다른 ConcreteState 역할을 알아야한다'는 점
  - 예시에서도 DayState 내부에서 NightState.getInstance()를 호출했고, 반대도 마찬가지이다
  - 상태 전환을 ConcreteState에게 맡기면 클래스 사이의 의존관계를 깊게 한다