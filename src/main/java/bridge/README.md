# Bridge 패턴 📚 - 기능 계층과 구현 계층 분리하기

### Bridge
- 두 장소를 연결하는 역할
##### 새로운 `기능`을 추가하고 싶은 경우
- `기본 기능`의 상위 클래스 + (`추가 기능`마다 하위 클래스) = 기능의 클래스 계층
    - *일반적으로 클래스 계층은 너무 깊게 파지 않는 것이 좋다!*
##### 새로운 `구현`을 추가하고 싶은 경우
- `추상 메소드에 의해 인터페이스(API)`를 규정한 상위 클래스 + `구체적으로 구현`한 하위 클래스 = **구현의 클래스 계층**
##### 클래스 계층의 혼재와 클래스 계층의 분리
- 💭 나는 기능을 추가하는가? 구현을 수행하는가?
- '기능의 클래스 계층'과 '구현의 클래스 계층'을 분리하고 두 계층 사이에 다리를 놓는 일이 필요 

---


#### 예제



--- 
### Bridge 패턴의 등장인물
- Abstraction(추상화)의 역할
  - `기능의 클래스 계층`의 최상위 클래스
  - **Implementor의 역할의 메소드를 사용**!! -> 기본적인 기능만이 기술되어 있는 클래스
- RefinedAbstraction(개선된 추상화)의 역할
  - Abstraction 역할에 대해 **기능을 추가**
- Implementor(구현자)의 역할
  - `구현의 클래스 계층`의 최상위 클래스
  - Abstraction 역할의 인터페이스(API)를 구현하기 위한 **메소드 규정**
- Concrete Implementor(구체적인 구현자)의 역할
  - Implementor 역할의 인터페이스를 구체적으로 구현
---
# 📌 Check

---

### TIP! 분리해두면 확장이 편해진다
- Bridge 패턴의 특징은 '기능의 클래스 계층'과 '구현의 클래스 계층'을 분리하는 것인데, **각각 클래스 계층을 독립적으로 확장 가능**
  - 새로 기능을 추가하더라도 모든 구현에서 이용 가능

### 상속은 견고한 연결이고 위임은 느슨한 연결
- 상속 : 클래스를 확장하기 위해 편리한 방법이지만, 클래스간의 연결을 강하게 고정
  - 소스코드를 고쳐 쓰지 않는 한 바꿀 수 없는 매우 견고한 연결이 된다
- 위임 : Display는 impl 필드를 통해 기능의 메소드를 규정을 떠넘기고, 구현되는 인스턴스를 간단하게 바꿀 수 있다