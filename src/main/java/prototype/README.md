# Prototype 패턴 📚 - 복사해서 인스턴스 만들기

### Prototype
- **인스턴스**를 통해 **별도의 인스턴스**를 생성
- 자바에서 객체 인스턴스를 작성할 때는 `new Object()`같이 new 키워드를 사용하고, 반드시 클래스 이름을 지정해서 인스턴스를 생성한다 <br>
  BUT, 클래스 이름을 지정하지 않고 인스턴스를 생성할 때도 있다
  
**클래스로부터 인스턴스를 만드는 것이 아닌 인스턴스를 복사해서 새로운 인스턴스를 만드는 경우**
1. 종류가 너무 많아 클래스로 정리되지 않는 경우
2. 클래스로부터 인스턴스 생성이 어려운 경우
  - 복잡한 과정을 걸쳐 만들어지기 때문에 어려운 경우
  - 사용자 조작으로 만들어진 인스턴스를 다시 만들 경우, 지금 있는 인스턴스를 일단 저장해두고 만들고 싶은 경우에 그것을 복사
3. framework와 생성할 인스턴스를 분리하고 싶은 경우
  - 인스턴스 생성의 framework를 특정 클래스에 의존하지 않도록 만들고 싶은 경우
---


#### 예제



--- 
### Prototype 패턴의 등장인물
- Prototype(원형)의 역할
  - 인스턴스를 복사하여 새로운 인스턴스를 만들기 위한 메소드를 **결정**
- ConcretePrototype(구체적인 원형)의 역할
  - 인스턴스를 복사하여 새로운 인스턴스를 만들기 위한 메소드를 **실제로 구현**
- Client(이용자)의 역할
  - 메소드를 이용해서 새로운 인스턴스를 생성
---
# 📌 Check

---

### REMIND WHY? 왜 Prototype 패턴이 필요할까?
###-> 클래스로부터 인스턴스를 만드는 것이 아닌 인스턴스를 복사해서 새로운 인스턴스를 만드는 경우
1. 종류가 너무 많아서 클래스로 정리할 수 없는 경우
예제 프로그램에서도 밑줄/테두리를 사용하여 글씨를 꾸미는 방법이 3가지 나왔다.
BUT, 마음먹기에 따라 얼마든지 많은 종류의 모형이 만들어 질 수 있다.
   
<br>

2. 클래스로부터 인스턴스 생성이 어려운 경우

-> 예시 : 마우스를 사용해서 도형을 편집하는 에디터
- 사용자가 조작을 해서 만든 도형을 나타내는 인스턴스와 같은 것을 만들고 싶다고 가정,   
- 클래스를 사용하는 것이 아닌 인스턴스를 복사해서 만드는 방법이 간단

<br>

3. framework와 생성하는 인스턴스를 분리하고 싶은 경우
- Manager 클래스의 create 메소드는 클래스 이름을 선언하는 대신 `key:value` 방식의 key 문자열로 이름을 제공함
- 클래스 이름의 속박으로부터 framework를 분리

 
<br>

### WHY? 소스 프로그램 내부에 클래스 이름을 쓰는것이 왜 문제일까?
- OOP의 목표 중 하나는 '부품으로써 재이용'이다
- 클래스의 이름을 쓰는 것이 항상 나쁘지는 않지만, 소스 내부에 이용할 클래스의 이름이 쓰여있으면 그 클래스와 분리해서 재이용할 수 없게 된다
> **Point!**
> 소스 파일(.java) 없이 클래스 파일(.class)만 가지고 있더래도 그 클래스를 재이용할 수 있는지가 중요

<br>


---

## ➕  Addtional Info

### clone 메소드와 java.lang.Cloneable 인터페이스

##### clone() method
- `java.lang.Object` 기본 클래스에 정의 -> 어느 클래스에서도 clone 메소드 상속 가능
- 인스턴스의 복사를 실행하는 도구
- 복사 대상이 되는 클래스는 java.lang.Cloneable 인터페이스를 구현할 필요가 있다
  - Cloneable 인터페이스를 구현하지 않은 클래스 인스턴스가 clone()을 호출한다면, `CloneNotSupportedException`이 발생
  - Cloneable 인터페이스에는 메소드가 하나도 선언되어 있지 않으며, 단지 'clone에 의해 복사 가능'의 표시로서 사용
- clone()를 사용헤서 복사를 한 경우, 얕은 복사(shallow copy)를 실행
  - 얕은 복사로는 곤란한 경우 오버라이딩을 통해 필요한 복사 정의 -> super.clone()  메소드 호출 필수
